<h1 align="center">
 <img src="https://user-images.githubusercontent.com/45159366/161355807-d03abccc-486e-4474-8134-5b75abb18fa1.png">
  <br />
 Qt Guide
</h1>

#### A guide covering the Qt programming language including the applications and tools that will make you a better and more efficient Qt developer.

 **Note: You can easily convert this markdown file to a PDF in [VSCode](https://code.visualstudio.com/) using this handy extension [Markdown PDF](https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf).**
 
  <p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/131386330-372f5872-e005-4d35-912a-582e4020535a.png">
  <br />
</p>

# Table of Contents
 
1. [Qt Learning Resources](https://github.com/mikeroyal/Qt-Guide#qt-learning-resources)

2. [Design Tools and Add-ons](https://github.com/mikeroyal/Qt-Guide#design-tools-and-add-ons)

3. [Development Tools](https://github.com/mikeroyal/Qt-Guide#development-tools)

4. [Framework Essentials and Add-ons](https://github.com/mikeroyal/Qt-Guide#framework-essentials-and-add-ons)

5. [Networking](https://github.com/mikeroyal/Qt-Guide#networking)

6. [Databases](https://github.com/mikeroyal/Qt-Guide#databases)

7. [KDE and the KDE Plasma Desktop](https://github.com/mikeroyal/Qt-Guide#kde-and-the-kde-plasma-desktop)

8. [Wayland Development](https://github.com/mikeroyal/Qt-Guide#wayland-development)

# Qt Learning Resources

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

[Qt](https://www.qt.io/) is a framework that allowers developeres to create modern UIs & applications for multiple screens accross multiple platforms such as Linux, Windows, macOS, Android, and other embedded systems.

[Qt QML](https://doc.qt.io/qt-5/qtqml-index.html) is a framework for developing applications and libraries with the QML language. It defines and implements the language and engine infrastructure, and provides an API to enable application developers to extend the QML language with custom types and integrate QML code with JavaScript and C++.

[Qt Features](https://www.qt.io/product/features)

[Qt marketplace](https://marketplace.qt.io/)

[Qt for Python](https://www.qt.io/qt-for-python)

[Qt for WebAssembly](https://doc.qt.io/qt-5/wasm.html)

[Tools for ActiveQt](https://doc.qt.io/qt-6/activeqt-tools.html)

[Qt Design User Interfaces for Applications](https://www.qt.io/design)

### Qt training and Courses

 - [Qt Resource Center](https://resources.qt.io/)

 - [Qt training by The Qt Company](https://www.qt.io/qt-training/)

 - [Qt for Educational Programs](https://www.qt.io/qt-for-educational-program)

 - [Get Qt certified](https://www.qt.io/qt-certification/)

 - [QT Framework Courses Online on Udemy](https://www.udemy.com/topic/qt-framework/)

 - [Learning Qt Quick Fundamentals on Pluralsight](https://www.pluralsight.com/courses/qt-quick-fundamentals)

### Deploying on Qt

 - [Deploy With Qt](https://www.qt.io/deploy)

 - [Deploying Qt Projects with Boot to Qt](https://doc.qt.io/QtForDeviceCreation/b2qt-deploying-b2qt.html)

 - [Deploying an Application on Android](https://doc.qt.io/qt-6/android-deploy-qt-tool.html)

### Qt Books and Manuals

 - [Qt6 QML Book](https://www.qt.io/product/qt6/qml-book)
 
 - [QML Coding Guidelines](https://github.com/Furkanzmc/QML-Coding-Guide)

 - [Qt Creator Manual](https://doc.qt.io/qtcreator/index.html)

 - [Qt Design Studio Manual](https://doc.qt.io/qtdesignstudio/index.html)

 - [Qt Linguist Manual](https://doc.qt.io/qt-6/qtlinguist-index.html)

 - [Qmake Manual](https://doc.qt.io/qt-6/qmake-manual.html)

 - [QDoc Manual](https://doc.qt.io/qt-6/qdoc-index.html)

 - [Qt Distance Field Generator Manual](https://doc.qt.io/qt-6/qtdistancefieldgenerator-index.html)

 - [Qt Assistant Quick Guide](https://doc.qt.io/qt-6/assistant-quick-guide.html)


## Design Tools and Add-ons

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

[Qt Designer Studio](https://doc.qt.io/qtdesignstudio/index.html) is a set of UI design tools that can provide the look and feel of the UI from wireframe to final implementation with Qt's ready-made UI components. Designers can import UI design files from Adobe Photoshop, Sketch, Maya, MODO, or Blender to Qt Design Studio, which can turn them into code for your developers.

<p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/131386334-9ba229b9-0279-47fa-b834-09767f28ee2d.png">
  <br />
</p>

**Qt Designer Studio. Source: [Qt](https://www.qt.io/)**

[Qt 3D Studio](https://doc.qt.io/qt3dstudio/index.html) is a compositing tool where you import 3D models, images and other assets to create interactive presentations, UIs and applications. 

[Qt Designer](https://doc.qt.io/qt-6/qtdesigner-manual.html) is the Qt tool for designing and building graphical user interfaces (GUIs) with [Qt Widgets](https://doc.qt.io/qt-6/qtwidgets-index.html).

[Qt Shader Tools](https://doc.qt.io/qt-6/qtshadertools-index.html) is a module that builds on the SPIR-V Open Source Ecosystem as described at the [Khronos SPIR-V web site](https://www.khronos.org/spir/). For compiling into SPIR-V [glslang](https://github.com/KhronosGroup/glslang) is used, while translating and reflecting is done via [SPIRV-Cross](https://github.com/KhronosGroup/SPIRV-Cross).

[QmlLive](https://doc.qt.io/qt-6/qtquick-tools-and-utilities.html#qmllive) is a 3rd party tool that offers a QML runtime capable of rendering changes to the code in realtime. It avoids the need to rebuild the application after every code change and install it on the target device. You can also extend it to build a custom runtime that suits your needs.

[Qt GUI](https://doc.qt.io/qt-6/qtgui-index.html) is a module that provides classes for windowing system integration, event handling, OpenGL and OpenGL ES integration, 2D graphics, basic imaging, fonts and text. 

[Qt Quick 3D](https://doc.qt.io/qt-6/qtquick3d-index.html) is a tool that provides a high-level API for creating 3D content and 3D user interfaces based on [Qt Quick](https://doc.qt.io/qt-6/qtquick-index.html). 

[Qt 3D](https://doc.qt.io/qt-6/qt3d-index.html) is a tool that provides functionality for near-realtime simulation systems with support for 2D and 3D rendering in both Qt C++ and Qt Quick applications.

[Qt OpenGL](https://doc.qt.io/qt-6/qtopengl-index.html) is a module that contains convenience classes to make possible to combine code written in the OpenGL graphics API with both these user interface types in Qt. 

[Qt Safe Renderer](https://doc.qt.io/QtSafeRenderer/index.html) is a module that provides a UI rendering component that can be used to render safety-critical items, such as warning indicators, in functional safety systems. Qt Safe Renderer separates the safety-critical rendering from the other parts of the system.

[Qt Lottie Animation](https://doc.qt.io/qt-6/qtlottieanimation-index.html) is a QML API for rendering graphics and animations that are exported in JSON format by the [Bodymovin](https://aescripts.com/bodymovin/) plugin for Adobe After Effects.

[Qt Scalable Vector Graphics (SVG)](https://doc.qt.io/qt-6/qtsvg-index.html) is an XML-based language for describing two-dimensional vector graphics. Qt provides classes for rendering and displaying SVG drawings in widgets and on other paint devices.

[Qt Charts](https://doc.qt.io/qt-6/qtcharts-index.html) is a module that provides a set of easy to use chart components. It uses the Qt Graphics View Framework, therefore charts can be easily integrated to modern user interfaces. 

[Qt Data Visualization](https://doc.qt.io/qt-6/qtdatavisualization-index.html) is a module that provides a way to visualize data in 3D as bar, scatter, and surface graphs. It is especially useful for visualizing depth maps and large quantities of rapidly changing data, such as data received from multiple sensors. 

## Development Tools

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

[Qt Creator](https://doc.qt.io/qtcreator/index.html) is a cross-platform, complete integrated development environment (IDE) for application developers to create applications for multiple [desktop](https://doc.qt.io/qtcreator/creator-desktop-platforms.html), [embedded](https://doc.qt.io/qtcreator/creator-embedded-platforms.html), and [mobile device](https://doc.qt.io/qtcreator/creator-mobile-platforms.html) platforms, such as [Android](https://doc.qt.io/qt-6/android.html) and [iOS](https://doc.qt.io/qt-6/ios.html). It is available for [Linux](https://doc.qt.io/qtcreator/creator-desktop-platforms.html#linux), [macOS](https://doc.qt.io/qtcreator/creator-desktop-platforms.html#macos) and [Windows](https://doc.qt.io/qtcreator/creator-desktop-platforms.html#windows).

<p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/117718859-8b471d80-b191-11eb-85e1-ad0e4e5500a0.png">
  <br />
</p>

**Qt Creator. Source: [Qt](https://www.qt.io/product/development-tools)**

[Qt VS Tools](https://doc.qt.io/qtvstools/index.html) is the integration of the Qt development tools into [Microsoft Visual Studio](https://visualstudio.microsoft.com/) 2017 or later. This enables developers to use the standard Windows development environment without having to worry about Qt-related build steps or tools. 

[CMake](https://doc.qt.io/qt-6/cmake-manual.html) is a tool to simplify the build process for development projects across different platforms. CMake automatically generates build systems, such as Makefiles and Ninja files.

[QML profiler](https://doc.qt.io/qt-6/qtquick-tools-and-utilities.html#qml-profiler) is a tool that enables you to get necessary diagnostic information, allowing you to analyze the application code for performance issues. For example, too much JavaScript in each frame, long-running C++ functions, and so on.

[QML debugger](https://doc.qt.io/qt-6/qtquick-tools-and-utilities.html#qml-debugger) is a very useful utility that enables:

   - Debugging JavaScript functions.
   - Executing JavaScript expressions.
   - Inspecting QML properties.

[PyQt](http://www.riverbankcomputing.com/software/pyqt/) is a set of Python v2 and v3 bindings for Qt and runs on all platforms supported by Qt including Windows, MacOS/X and Linux. 

[PySide](http://qt-project.org/wiki/PySide) is a project that provides LGPL-licensed Python bindings for the Qt. It also includes complete toolchain for rapidly generating bindings for any Qt-based C++ class hierarchies.

[PyOtherSide](http://thp.io/2011/pyotherside/) is a Qt 5 QML Plugin that provides access to a Python 3 interpreter from QML.

[Qml.Net](https://github.com/pauldotknopf/Qml.Net) is a cross-platform integration of Qml/QtQuick for .NET Core/.NET Framework/Mono. It is a binding that brings .NET types into JavaScript with full interoperability.

[DOtherside](https://github.com/filcuc/DOtherSide) is a C language library for creating bindings for the Qt QML language

[QxOrm library](http://www.qxorm.com/) is an Object Relational Mapping (ORM) library for C++/Qt developers.

[QtMongo](https://github.com/manuels/QtMongo) is a Bindings for QML to MongoDB.

[QmlSql](https://github.com/JosephMillsAtWork/QmlSql) is a  couple of wrapper classes that are for QSql.

[Sqlite-editor-qtqml](https://github.com/ndesai/sqlite-editor-qtqml) is a SQLite Editor written in Qt+QML.

[QML CVCamera](https://github.com/chili-epfl/qml-cvcamera) is a QML wrapper for fast camera access using OpenCV. It works on desktop and Android.

[Pot](https://github.com/carlonluca/pot) is a Raspberry Pi accelerated video/image rendering with Qt: custom QML components and QtMultimedia backend.

[QtJoysticks](https://github.com/alex-spataru/QJoysticks) is a library allows your Qt application to read input from both real joysticks/gamepads (using SDL) and a virtual joystick (using the keyboard).

[QmlPedalboard](https://github.com/danieloneill/QmlPedalboard) is a Udev rule, a tiny Arduino program, a Qml Component, and a test Qml app to interface a pedal board with QML.

[QtFirebase](https://github.com/Larpon/QtFirebase) is an effort to bring the Firebase C++ API to Qt + QML.

[GammaRay™](https://marketplace.qt.io/collections/qt-tools/products/gammaray-1) is a debugger that allows the user to observe behavior and data structures of Qt code inside their program live at runtime.
    
[Daggy](https://marketplace.qt.io/collections/qt-tools/products/daggy) is a server-less remote or local data aggregation and streaming utility.

[GitQlient](https://marketplace.qt.io/collections/qt-tools/products/gitqlient) is a multi-platform Git client written with Qt.

[Incredibuild](https://marketplace.qt.io/collections/qt-tools/products/incredibuild) is a plug-and-play solution that empowers Qt users to dramatically reduce their Qt applications build times.

[KDED](https://marketplace.qt.io/collections/qt-tools/products/kded) is a central daemon of KDE workspaces running in the background and performs a number of small tasks that are built-in and others that run on demand.

[Qaterial](https://github.com/OlivierLDff/Qaterial) is a collection of Material Components to build faster UI using Qml.

[Mini-QML](https://github.com/patrickelectric/mini-qml) is a minimal Qt deployment for Linux, Windows, macOS and WebAssembly.

[Squish](https://doc.qt.io/qt-6/qtquick-tools-and-utilities.html#squish) is a well-known testing tool that automates UI testing by recording your actions or running scripts. Once the tests are setup, UI tests are a lot easier to run.

[Squish Coco](https://doc-snapshots.qt.io/squishcoco/index.html) is a complete code coverage tool chain for Tcl, QML, C# and C/C++ programs (including SystemC programs). It runs on macOS, Linux™ and Microsoft® Windows.

[Squish Test Center](https://doc-snapshots.qt.io/testcenter/index.html) is a result server, or a central place where you can store all your test results.

[qmllint](https://doc.qt.io/qt-6/qtquick-tool-qmllint.html) is a tool shipped with Qt, that verifies the syntatic validity of QML files. It also warns about some QML anti-patterns. If you want to disable a specific warning type, you can find the appropriate flag for doing so by passing --help on the command line.

[qmlformat](https://doc.qt.io/qt-6/qtquick-tools-and-utilities.html#qmlformat) is a tool that automatically formats QML files in accordance with the [QML Coding Conventions](https://doc.qt.io/qt-6/qml-codingconventions.html).

[Qt Quick Ultralite](https://doc.qt.io/QtForMCUs-2.1/qtul-overview.html) is a tool that brings the key graphical user interface features of Qt to resource-constrained embedded systems powered by microcontrollers (MCU). It provides a rich QML API set for building fluid GUIs, and an efficient graphics engine to render Qt Quick-based graphical user interfaces (GUI).

[Qt Quick Ultralite Controls](https://doc.qt.io/QtForMCUs-2.1/qtquick-controls-qmlmodule.html) is an implementation of Qt Quick Controls that targets MCU devices. 

[Qt 5 Core Compat](https://doc.qt.io/qt-6/qtcore5-index.html) is a module that contains the Qt Core APIs which will be no longer supported in Qt 6 and therefore were removed from Qt 6. The module is provided to facilitate the transition to Qt 6.

[Qt State Machine State Machine](https://doc.qt.io/qt-6/qtstatemachine-index.html) is a framework provides classes for creating and executing state graphs.

[Neptune 3 UI](https://doc.qt.io/Neptune3UI/index.html) is a tool that provides a UI implementation for Qt in In-Vehicle Infotainment (IVI) systems. It demonstrates best practices for developing an Automotive UI with [Qt Automotive Suite](http://www.qt.io/qt-automotive-suite/). 

[Qt for Android Automotive](https://doc.qt.io/QtAndroidAutomotive-6.2/index.html) is a set of tools that integrates the Qt Framework, including the UI toolkit, with Android bindings, the Qt IF framework, and the Android Automotive bindings. 

[Simulating Dynamic Systems](https://doc.qt.io/qtdesignstudio/studio-simulink.html) is a Simulink connector to connect simulation to your UI. [Simulink](https://www.mathworks.com/products/simulink.html) is a [MATLAB](https://www.mathworks.com/products/matlab.html)-based graphical programming environment for modeling, simulating, and analyzing multi-domain dynamic systems. 

[Qt Sensors](https://doc.qt.io/qt-6/qtsensors-index.html) is an API that provides access to sensor hardware via QML and C++ interfaces. Currently the API is supported on [Android](https://doc.qt.io/qt-6/android.html), [iOS](https://doc.qt.io/qt-6/ios.html), and [Windows (MSVC)](https://doc.qt.io/qt-6/windows.html).

[makeqpf](https://doc.qt.io/qt-6/qt-embedded-makeqpf.html) is a tool to generate pre-rendered fonts in QPF2 format for use on Embedded Linux.

[Meta-Object Compiler (MOC)](https://doc.qt.io/qt-6/moc.html) is the program that handles [Qt's C++ extensions](https://doc.qt.io/qt-6/metaobjects.html).

[User Interface Compiler (UIC)](https://doc.qt.io/qt-6/uic.html) is a tool for the Qt Widgets module. The uic reads an XML format user interface definition (.ui) file as generated by Qt Designer and creates a corresponding C++ header file.

[Resource Compiler (rcc)](https://doc.qt.io/qt-6/rcc.html) is a tool is used to embed resources into a Qt application during the build process. It works by generating a C++ source file containing data specified in a Qt resource (.qrc) file.

[Qt D-Bus XML compiler (qdbusxml2cpp)](https://doc.qt.io/qt-6/qdbusxml2cpp.html)  is a tool that can be used to parse interface descriptions and produce static code representing those interfaces, which can then be used to make calls to remote objects or implement said interfaces.

[Qt D-Bus Viewer](https://doc.qt.io/qt-6/qdbusviewer.html) is a tool that lets you introspect D-Bus objects and messages. It can choose between the system bus and the session bus. Click on any service on the list on the left side to see all the exported objects.

[Qt Installer Framework](https://doc.qt.io/qtinstallerframework/index.html) is a set of tools and utilities to create installers for the supported desktop Qt platforms: Linux, Microsoft Windows, and macOS.

[Qt Assistant](https://doc.qt.io/qt-6/qtassistant-index.html) is a tool for viewing on-line documentation in Qt help file format.

[Windows deployment tool (windeployqt)](https://doc.qt.io/qt-6/windows-deployment.html) is a tool designed to automate the process of creating a deployable folder containing the Qt-related dependencies (libraries, QML imports, plugins, and translations) required to run the application from that folder. It creates an installation tree for Windows desktop applications, which can be easily bundled into an installation package.

[Shiboken](https://doc.qt.io/qtforpython/shiboken6/index.html) is a fundamental piece on the Qt for Python project that serves two purposes:

   - [Generator](https://doc.qt.io/qtforpython/shiboken6/shibokengenerator.html): Extract information from C or C++ headers and generate [CPython](https://github.com/python/cpython) code that allow to bring C or C++ projects to Python. This process uses a library called [ApiExtractor](https://doc.qt.io/qtforpython/shiboken6/typesystem.html) which internally uses [Clang](https://clang.llvm.org/).

   - [Module](https://doc.qt.io/qtforpython/shiboken6/shibokenmodule.html): An utility Python module that exposed new Python types, functions to handle pointers, among other things, that is written in [CPython](https://github.com/python/cpython) and can use independently of the generator.

## Framework Essentials and Add-ons

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

[Qt Core](https://doc.qt.io/qt-6/qtcore-index.html) is a module that adds essential features to C++ such as:

   - 1. A very powerful mechanism for seamless object communication called signals and slots.
   - 2. queryable and designable object properties.
   - 3. Hierarchical and queryable object trees that organize.
   - 4. Object ownership in a natural way with guarded pointers [(QPointer)](https://doc.qt.io/qt-6/qpointer.html).
   - 5. A dynamic cast that works across library boundaries.

[Qt QML](https://doc.qt.io/qt-6/qtqml-index.html) is a module that provides a framework for developing applications and libraries with the [QML language](https://doc.qt.io/qt-6/qmlapplications.html). It defines and implements the language and engine infrastructure, and provides an API to enable application developers to extend the QML language with custom types and integrate QML code with JavaScript and C++. The Qt QML module provides both a [QML API](https://doc.qt.io/qt-6/qtqml-qmlmodule.html) and a [C++ API](https://doc.qt.io/qt-6/qtqml-module.html).

[Qt Quick Dialogs](https://doc.qt.io/qt-6/qtquickdialogs-index.html) is a module that allows to create and interact with system dialogs from QML. The module was introduced in Qt 6.2.

[Qt Quick Layouts](https://doc.qt.io/qt-6/qtquicklayouts-index.html) are a set of QML types used to arrange items in a user interface. In contrast to [positioners](https://doc.qt.io/qt-6/qtquick-positioning-layouts.html), Qt Quick Layouts can also resize their items. This makes them well suited for resizable user interfaces. 

[Qt Quick module](https://doc.qt.io/qt-6/qtquick-index.html) is the standard library for writing QML applications. While the [Qt QML](https://doc.qt.io/qt-6/qtqml-index.html) module provides the QML engine and language infrastructure, the Qt Quick module provides all the basic types necessary for creating user interfaces with QML.

[Qt D-Bus](https://doc.qt.io/qt-6/qtdbus-index.html) is an Inter-Process Communication (IPC) and Remote Procedure Calling (RPC) mechanism originally developed for Linux to replace existing and competing IPC solutions with one unified protocol. 

[Qt Quick Controls](https://doc.qt.io/qt-6/qtquickcontrols-index.html) is a tool that provides a set of controls that can be used to build complete interfaces in Qt Quick. The module was introduced in Qt 5.7.

[Qt Test module](https://doc.qt.io/qt-6/qttest-index.html) is a tool that provides classes for unit testing Qt applications and libraries. All public methods are in the [QTest](https://doc.qt.io/qt-6/qtest.html) namespace. In addition, the [QSignalSpy](https://doc.qt.io/qt-6/qsignalspy.html) class provides easy introspection for Qt's signals and slots, and the [QAbstractItemModelTester](https://doc.qt.io/qt-6/qabstractitemmodeltester.html) allows for non-destructive testing of item models.

[Qt Widgets Module](https://doc.qt.io/qt-6/qtwidgets-index.html) is a tool that provides a set of UI elements to create classic desktop-style user interfaces. 

[Qt Digital Advertising](https://doc.qt.io/QtDigitalAdvertising/) is a service that offers light-weight QML API to enable developers to monetize from advertisements in their applications for multiple desktop, embedded, and mobile device platforms, such as Android and iOS.

[Qt Multimedia](https://doc.qt.io/qt-6/qtmultimedia-index.html) is an add-on module that provides a rich set of QML types and C++ classes to handle multimedia content. It contains an easy to use API for playing back audio and video files and rendering those on screen, as well as a comprehensive API for recording audio and video from the systems cameras and microphones.

[Qt Bluetooth API](https://doc.qt.io/qt-6/qtbluetooth-index.html) is an API that provides connectivity between Bluetooth enabled devices.

[Qt Concurrent](https://doc.qt.io/qt-6/qtconcurrent-index.html) is a module that provides high-level APIs that make it possible to write multi-threaded programs without using low-level threading primitives such as mutexes, read-write locks, wait conditions, or semaphores. 

[Qt Image Formats](https://doc.qt.io/qt-6/qtimageformats-index.html) is the core Qt Gui library by default supports reading and writing image files of the most common file formats: PNG, JPEG, BMP, GIF and a few more.

[Qt NFC](https://doc.qt.io/qt-6/qtnfc-index.html) is an API that provides connectivity between NFC enabled devices. Currently the API is supported on [Android](https://doc.qt.io/qt-6/android.html) and [iOS](https://doc.qt.io/qt-6/ios.html).

[Qt Interface Framework](https://doc.qt.io/QtInterfaceFramework/interfaceframework-index.html) is a module that provides both the tools and the core APIs, for you to implement Middleware APIs, Middleware Back ends, and Middleware Services.

[Qt Interface Framework Generator](https://doc.qt.io/QtInterfaceFramework/ifcodegen.html) is a tool that provides a flexible way to define new APIs via an Interface Definition Language (IDL) and generate classes for use, from C++ and QML.

[Qt Positioning](https://doc.qt.io/qt-6/qtpositioning-index.html) is an API that provides positioning information via QML and C++ interfaces. Currently the API is supported on [Android](https://doc.qt.io/qt-6/android.html), [iOS](https://doc.qt.io/qt-6/ios.html), [macOS](https://doc.qt.io/qt-6/macos.html), [Linux](https://doc.qt.io/qt-6/linux.html), and [Windows](https://doc.qt.io/qt-6/windows.html).

[Qt Print Support](https://doc.qt.io/qt-6/qtprintsupport-index.html) is a module that provides extensive cross-platform support for printing. Using the printing systems on each platform, Qt applications can print to attached printers and across networks to remote printers. 

[Qt Quick Widgets C++ Classes](https://doc.qt.io/qt-6/qtquickwidgets-module.html) is a C++ API provided by the Qt Quick Widgets module.

[Qt SCXML](https://doc.qt.io/qt-6/qtscxml-index.html) is a module that provides functionality to create state machines from SCXML files.

[Qt Serial Bus](https://doc.qt.io/qt-6/qtserialbus-index.html) is an API that provides classes and functions to access the various industrial serial buses and protocols, such as CAN, ModBus, and others.

[Qt Serial Port](https://doc.qt.io/qt-6/qtserialport-index.html) is a tool that provides the basic functionality, which includes configuring, I/O operations, getting and setting the control signals of the RS-232 pinouts.

[Qt WebChannel](https://doc.qt.io/qt-6/qtwebchannel-index.html) is a tool that enables peer-to-peer communication between a server (QML/C++ application) and a client (HTML/JavaScript or QML application). It is supported out of the box by [Qt WebEngine](https://doc.qt.io/qt-6/qtwebengine-index.html). 

[Qt WebEngine](https://doc.qt.io/qt-6/qtwebengine-index.html) is a tool that provides functionality for rendering regions of dynamic web content.

[Qt WebSocket](https://doc.qt.io/qt-6/qtwebsockets-index.html) is a web-based protocol designed to enable two-way communication between a client application and a remote host. It enables the two entities to send data back and forth if the initial handshake succeeds. 

[Qt WebView](https://doc.qt.io/qt-6/qtwebview-index.html) is a tool that provides a way to display web content in a QML application without necessarily including a full web browser stack by using native APIs where it makes sense. This is useful on mobile platforms such as [Android](https://doc.qt.io/qt-6/android.html) and [iOS](https://doc.qt.io/qt-6/ios.html).

[Qt XML](https://doc.qt.io/qt-6/qtxml-index.html) is a module that provides implementations of the SAX and DOM standards for XML.

[Qt Wayland Compositor](https://doc.qt.io/qt-6/qtwaylandcompositor-index.html) is a module that provides convenient and powerful QML and C++ APIs for developing custom display servers based on the [Wayland](https://wayland.freedesktop.org/) protocol.

[Qt Virtual Keyboard](https://doc.qt.io/qt-6/qtvirtualkeyboard-index.html) is a project that provides an input framework and reference keyboard frontend for Qt 6 on Linux Desktop/X11, Windows Desktop, and Boot2Qt targets.

[Qt Application Manager](https://doc.qt.io/QtApplicationManager/index.html) is a binary (appman) is a headless daemon by itself. You need to supply a suitable QML file via the command-line or via a config file at startup, which then acts as a compositing window manager using the APIs that are exported from the C++ side.

[Qt Device Utilities](https://doc.qt.io/QtDeviceUtilities/index.html) is a tool that provides functionality that is useful for controlling settings in embedded applications.

[Qt MQTT](https://doc.qt.io/QtMQTT/index.html) is a machine-to-machine (M2M) protocol utilizing the publish-and-subscribe paradigm. Its purpose is to provide a channel with minimal communication overhead.

[Qt OPC UA](https://doc.qt.io/QtOPCUA/index.html) is a module that implements a Qt API to interact with OPC UA on top of a 3rd party OPC UA stack.

[Qt PDF](https://doc-snapshots.qt.io/qt6-6.3/qtpdf-index.html) is a module that contains classes and functions for rendering PDF documents.

# Networking

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

<p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/82833053-d1687b80-9e71-11ea-8c6d-074100f2f54b.png">
  <br />
</p>

**[Qt Network in Qt 6](https://www.qt.io/blog/qt-network-in-qt-6)**

## Networking Tools & Concepts

[Qt Network Authorization](https://doc.qt.io/qt-6/qtnetworkauth-index.html) is a tool that provides a set of APIs that enable Qt applications to obtain limited access to online accounts and HTTP services without exposing users' passwords.

[cURL](https://curl.se/) is a computer software project providing a library and command-line tool for transferring data using various network protocols(HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, LDAP LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP or SMTPS). cURL is also used in cars, television sets, routers, printers, audio equipment, mobile phones, tablets, settop boxes, media players and is the Internet transfer engine for thousands of software applications in over ten billion installations.

[cURL Fuzzer](https://github.com/curl/curl-fuzzer) is a quality assurance testing for the curl project.

[DoH](https://github.com/curl/doh) is a stand-alone application for DoH (DNS-over-HTTPS) name resolves and lookups.

[Authelia](https://www.authelia.com/) is an open-source highly-available authentication server providing single sign-on capability and two-factor authentication to applications running behind [NGINX](https://nginx.org/en/).

[nginx(engine x)](https://nginx.org/en/) is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server, originally written by Igor Sysoev.

[Proxmox Virtual Environment(VE)](https://www.proxmox.com/en/) is a complete open-source platform for enterprise virtualization. It inlcudes a built-in web interface that you can easily manage VMs and containers, software-defined storage and networking, high-availability clustering, and multiple out-of-the-box tools on a single solution.

[Wireshark](https://www.wireshark.org/) is a very popular network protocol analyzer that is commonly used for network troubleshooting, analysis, and communications protocol development. Learn more about the other useful [Wireshark Tools](https://wiki.wireshark.org/Tools) available.

[HTTPie](https://github.com/httpie/httpie) is a command-line HTTP client. Its goal is to make CLI interaction with web services as human-friendly as possible. HTTPie is designed for testing, debugging, and generally interacting with APIs & HTTP servers.

[HTTPStat](https://github.com/reorx/httpstat) is a tool that visualizes curl statistics in a simple layout.

[Wuzz](https://github.com/asciimoo/wuzz) is an interactive cli tool for HTTP inspection. It can be used to inspect/modify requests copied from the browser's network inspector with the "copy as cURL" feature.

[Websocat](https://github.com/vi/websocat) is a ommand-line client for WebSockets, like netcat (or curl) for ws:// with advanced socat-like functions.

   - Connection: In networking, a connection refers to pieces of related information that are transferred through a network. This generally infers that a connection is built before the data transfer (by following the procedures laid out in a protocol) and then is deconstructed at the at the end of the data transfer.

   - Packet: A packet is, generally speaking, the most basic unit that is transferred over a network. When communicating over a network, packets are the envelopes that carry your data (in pieces) from one end point to the other.

Packets have a header portion that contains information about the packet including the source and destination, timestamps, network hops. The main portion of a packet contains the actual data being transferred. It is sometimes called the body or the payload.

   - Network Interface: A network interface can refer to any kind of software interface to networking hardware. For instance, if you have two network cards in your computer, you can control and configure each network interface associated with them individually.

A network interface may be associated with a physical device, or it may be a representation of a virtual interface. The "loop-back" device, which is a virtual interface to the local machine, is an example of this.

   - LAN: LAN stands for "local area network". It refers to a network or a portion of a network that is not publicly accessible to the greater internet. A home or office network is an example of a LAN.

   - WAN: WAN stands for "wide area network". It means a network that is much more extensive than a LAN. While WAN is the relevant term to use to describe large, dispersed networks in general, it is usually meant to mean the internet, as a whole.
If an interface is connected to the WAN, it is generally assumed that it is reachable through the internet.

   - Protocol: A protocol is a set of rules and standards that basically define a language that devices can use to communicate. There are a great number of protocols in use extensively in networking, and they are often implemented in different layers.

Some low level protocols are TCP, UDP, IP, and ICMP. Some familiar examples of application layer protocols, built on these lower protocols, are HTTP (for accessing web content), SSH, TLS/SSL, and FTP.

   - Port: A port is an address on a single machine that can be tied to a specific piece of software. It is not a physical interface or location, but it allows your server to be able to communicate using more than one application.

   - Firewall: A firewall is a program that decides whether traffic coming into a server or going out should be allowed. A firewall usually works by creating rules for which type of traffic is acceptable on which ports. Generally, firewalls block ports that are not used by a specific application on a server.

   - NAT: Network address translation is a way to translate requests that are incoming into a routing server to the relevant devices or servers that it knows about in the LAN. This is usually implemented in physical LANs as a way to route requests through one IP address to the necessary backend servers.

   - VPN: Virtual private network is a means of connecting separate LANs through the internet, while maintaining privacy. This is used as a means of connecting remote systems as if they were on a local network, often for security reasons.

## Network Layers

While networking is often discussed in terms of topology in a horizontal way, between hosts, its implementation is layered in a vertical fashion throughout a computer or network. This means is that there are multiple technologies and protocols that are built on top of each other in order for communication to function more easily. Each successive, higher layer abstracts the raw data a little bit more, and makes it simpler to use for applications and users. It also allows you to leverage lower layers in new ways without having to invest the time and energy to develop the protocols and applications that handle those types of traffic.

As data is sent out of one machine, it begins at the top of the stack and filters downwards. At the lowest level, actual transmission to another machine takes place. At this point, the data travels back up through the layers of the other computer. Each layer has the ability to add its own "wrapper" around the data that it receives from the adjacent layer, which will help the layers that come after decide what to do with the data when it is passed off.

One method of talking about the different layers of network communication is the OSI model. OSI stands for [Open Systems Interconnect](https://en.wikipedia.org/wiki/OSI_model).This model defines seven separate layers. The layers in this model are:

   - Application: The application layer is the layer that the users and user-applications most often interact with. Network communication is discussed in terms of availability of resources, partners to communicate with, and data synchronization.

   - Presentation: The presentation layer is responsible for mapping resources and creating context. It is used to translate lower level networking data into data that applications expect to see.

   - Session: The session layer is a connection handler. It creates, maintains, and destroys connections between nodes in a persistent way.

   - Transport: The transport layer is responsible for handing the layers above it a reliable connection. In this context, reliable refers to the ability to verify that a piece of data was received intact at the other end of the connection. This layer can resend information that has been dropped or corrupted and can acknowledge the receipt of data to remote computers.

   - Network: The network layer is used to route data between different nodes on the network. It uses addresses to be able to tell which computer to send information to. This layer can also break apart larger messages into smaller chunks to be reassembled on the opposite end.

   - Data Link: This layer is implemented as a method of establishing and maintaining reliable links between different nodes or devices on a network using existing physical connections.

   - Physical: The physical layer is responsible for handling the actual physical devices that are used to make a connection. This layer involves the bare software that manages physical connections as well as the hardware itself (like Ethernet).

The TCP/IP model, more commonly known as the Internet protocol suite, is another layering model that is simpler and has been widely adopted.It defines the four separate layers, some of which overlap with the OSI model:

   - Application: In this model, the application layer is responsible for creating and transmitting user data between applications. The applications can be on remote systems, and should appear to operate as if locally to the end user.
The communication takes place between peers network.

   - Transport: The transport layer is responsible for communication between processes. This level of networking utilizes ports to address different services. It can build up unreliable or reliable connections depending on the type of protocol used.

   - Internet: The internet layer is used to transport data from node to node in a network. This layer is aware of the endpoints of the connections, but does not worry about the actual connection needed to get from one place to another. IP addresses are defined in this layer as a way of reaching remote systems in an addressable manner.

   - Link: The link layer implements the actual topology of the local network that allows the internet layer to present an addressable interface. It establishes connections between neighboring nodes to send data.

### Interfaces
**Interfaces** are networking communication points for your computer. Each interface is associated with a physical or virtual networking device. Typically, your server will have one configurable network interface for each Ethernet or wireless internet card you have. In addition, it will define a virtual network interface called the "loopback" or localhost interface. This is used as an interface to connect applications and processes on a single computer to other applications and processes. You can see this referenced as the "lo" interface in many tools.

## Network Protocols

Networking works by piggybacks on a number of different protocols on top of each other. In this way, one piece of data can be transmitted using multiple protocols encapsulated within one another.

**Media Access Control(MAC)** is a communications protocol that is used to distinguish specific devices. Each device is supposed to get a unique MAC address during the manufacturing process that differentiates it from every other device on the internet. Addressing hardware by the MAC address allows you to reference a device by a unique value even when the software on top may change the name for that specific device during operation. Media access control is one of the only protocols from the link layer that you are likely to interact with on a regular basis.

**The IP protocol** is one of the fundamental protocols that allow the internet to work. IP addresses are unique on each network and they allow machines to address each other across a network. It is implemented on the internet layer in the IP/TCP model. Networks can be linked together, but traffic must be routed when crossing network boundaries. This protocol assumes an unreliable network and multiple paths to the same destination that it can dynamically change between. There are a number of different implementations of the protocol. The most common implementation today is IPv4, although IPv6 is growing in popularity as an alternative due to the scarcity of IPv4 addresses available and improvements in the protocols capabilities.

**ICMP: internet control message protocol** is used to send messages between devices to indicate the availability or error conditions. These packets are used in a variety of network diagnostic tools, such as ping and traceroute. Usually ICMP packets are transmitted when a packet of a different kind meets some kind of a problem. Basically, they are used as a feedback mechanism for network communications.

**TCP: Transmission control protocol** is implemented in the transport layer of the IP/TCP model and is used to establish reliable connections. TCP is one of the protocols that encapsulates data into packets. It then transfers these to the remote end of the connection using the methods available on the lower layers. On the other end, it can check for errors, request certain pieces to be resent, and reassemble the information into one logical piece to send to the application layer. The protocol builds up a connection prior to data transfer using a system called a three-way handshake. This is a way for the two ends of the communication to acknowledge the request and agree upon a method of ensuring data reliability. After the data has been sent, the connection is torn down using a similar four-way handshake. TCP is the protocol of choice for many of the most popular uses for the internet, including WWW, FTP, SSH, and email. It is safe to say that the internet we know today would not be here without TCP.

**UDP: User datagram protocol** is a popular companion protocol to TCP and is also implemented in the transport layer. The fundamental difference between UDP and TCP is that UDP offers unreliable data transfer. It does not verify that data has been received on the other end of the connection. This might sound like a bad thing, and for many purposes, it is. However, it is also extremely important for some functions. It’s not required to wait for confirmation that the data was received and forced to resend data, UDP is much faster than TCP. It does not establish a connection with the remote host, it simply fires off the data to that host and doesn't care if it is accepted or not. Since UDP is a simple transaction, it is useful for simple communications like querying for network resources. It also doesn't maintain a state, which makes it great for transmitting data from one machine to many real-time clients. This makes it ideal for VOIP, games, and other applications that cannot afford delays.

**HTTP: Hypertext transfer protocol** is a protocol defined in the application layer that forms the basis for communication on the web. HTTP defines a number of functions that tell the remote system what you are requesting. For instance, GET, POST, and DELETE all interact with the requested data in a different way.

**FTP: File transfer protocol** is in the application layer and provides a way of transferring complete files from one host to another. It is inherently insecure, so it is not recommended for any externally facing network unless it is implemented as a public, download-only resource.

**DNS: Domain name system** is an application layer protocol used to provide a human-friendly naming mechanism for internet resources. It is what ties a domain name to an IP address and allows you to access sites by name in your browser.

**SSH: Secure shell** is an encrypted protocol implemented in the application layer that can be used to communicate with a remote server in a secure way. Many additional technologies are built around this protocol because of its end-to-end encryption and ubiquity. There are many other protocols that we haven't covered that are equally important. However, this should give you a good overview of some of the fundamental technologies that make the internet and networking possible.

[REST(REpresentational State Transfer)](https://www.codecademy.com/articles/what-is-rest) is an architectural style for providing standards between computer systems on the web, making it easier for systems to communicate with each other.

[JSON Web Token (JWT)](https://jwt.io) is a compact URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is digitally signed using JSON Web Signature (JWS).

[OAuth 2.0](https://oauth.net/2/) is an open source authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Amazon, Google, Facebook, Microsoft, Twitter GitHub, and DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account.

# Databases

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

<p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/119279004-daec0700-bbdd-11eb-9662-b1fc86ec8448.png">
  <br />
</p>

 <p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/119279002-da537080-bbdd-11eb-9d7a-44efb52f3506.png">
  <br />
</p>

# SQL Tools and Databases

**[SQL Programming with Qt](https://doc.qt.io/qt-5/sql-programming.html)**

[Qt SQL](https://doc.qt.io/qt-6/qtsql-index.html) is a module that provides support for SQL databases. Qt SQL's APIs are divided into different layers:

   - Driver layer
   - SQL API layer
   - User interface layer

[Netdata](https://github.com/netdata/netdata) is high-fidelity infrastructure monitoring and troubleshooting, real-time monitoring Agent collects thousands of metrics from systems, hardware, containers, and applications with zero configuration. It runs permanently on all your physical/virtual servers, containers, cloud deployments, and edge/IoT devices, and is perfectly safe to install on your systems mid-incident without any preparation.

[Azure Data Studio](https://github.com/Microsoft/azuredatastudio) is an open source data management tool that enables working with SQL Server, Azure SQL DB and SQL DW from Windows, macOS and Linux.

[MySQL](https://www.mysql.com/) is a fully managed database service to deploy cloud-native applications using the world's most popular open source database. 

[PostgreSQL](https://www.postgresql.org/) is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.

[MongoDB](https://www.mongodb.com/) is a document database meaning it stores data in JSON-like documents. 

[OracleDB](https://www.oracle.com/database/) is a powerful fully managed database helps developers manage business-critical data with the highest availability, reliability, and security.

[MariaDB](https://mariadb.com/) is an enterprise open source database solution for modern, mission-critical applications.

[SQLite](https://sqlite.org/index.html) is a C-language library that implements a small, fast, self-contained, high-reliability, full-featured, SQL database engine.SQLite is the most used database engine in the world. SQLite is built into all mobile phones and most computers and comes bundled inside countless other applications that people use every day.

[SQLite Database Browser](https://sqlitebrowser.org/) is an open source SQL tool that allows users to create, design and edits SQLite database files. It lets users show a log of all the SQL commands that have been issued by them and by the application itself. 

[InfluxDB](https://www.influxdata.com/) is an open source time series platform.  This includes APIs for storing and querying data, processing it in the background for [ETL](https://docs.microsoft.com/en-us/azure/architecture/data-guide/relational-data/etl) or monitoring and alerting purposes, user dashboards, Internet of Things sensor data, and visualizing and exploring the data and more. It also has support for processing data from [Graphite](http://graphiteapp.org/).

[DBeaver](https://dbeaver.io/) is an open source database tool for developers and database administrators. It offers supports for JDBC compliant databases such as MySQL, Oracle, IBM DB2, SQL Server, Firebird, SQLite, Sybase, Teradata, Firebird, Apache Hive, Phoenix, and Presto.

[Amazon DynamoDB](https://aws.amazon.com/dynamodb/) is a key-value and document database that delivers single-digit millisecond performance at any scale. It is a fully managed, multiregion, multimaster, durable database with built-in security, backup and restore, and in-memory caching for internet-scale applications.

[Apache HBase™](https://hbase.apache.org/) is an open-source, NoSQL, distributed big data store. It enables random, strictly consistent, real-time access to petabytes of data. HBase is very effective for handling large, sparse datasets. HBase serves as a direct input and output to the Apache MapReduce framework for Hadoop, and works with Apache Phoenix to enable SQL-like queries over HBase tables.

[Hadoop Distributed File System (HDFS)](https://www.ibm.com/analytics/hadoop/hdfs) is a distributed file system that handles large data sets running on commodity hardware. It is used to scale a single Apache Hadoop cluster to hundreds (and even thousands) of nodes. HDFS is one of the major components of Apache Hadoop, the others being [MapReduce](https://www.ibm.com/analytics/hadoop/mapreduce) and [YARN](https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html).

[Apache Mesos](http://mesos.apache.org/) is a cluster manager that provides efficient resource isolation and sharing across distributed applications, or frameworks. It can run Hadoop, Jenkins, Spark, Aurora, and other frameworks on a dynamically shared pool of nodes.

[Apache Spark](https://spark.apache.org/) is a unified analytics engine for big data processing, with built-in modules for streaming, SQL, machine learning and graph processing.

[ElasticSearch](https://www.elastic.co/) is a search engine based on the Lucene library. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java.

[Logstash](https://www.elastic.co/products/logstash) is a tool for managing events and logs. When used generically, the term encompasses a larger system of log collection, processing, storage and searching activities.

[Kibana](https://www.elastic.co/products/kibana) is an open source data visualization plugin for Elasticsearch. It provides visualization capabilities on top of the content indexed on an Elasticsearch cluster. Users can create bar, line and scatter plots, or pie charts and maps on top of large volumes of data.

[Trino](https://trino.io/) is a Distributed SQL query engine for big data. It is able to tremendously speed up [ETL processes](https://docs.microsoft.com/en-us/azure/architecture/data-guide/relational-data/etl), allow them all to use standard SQL statement, and work with numerous data sources and targets all in the same system.

[Extract, transform, and load (ETL)](https://docs.microsoft.com/en-us/azure/architecture/data-guide/relational-data/etl) is a data pipeline used to collect data from various sources, transform the data according to business rules, and load it into a destination data store.

[Redis(REmote DIctionary Server)](https://redis.io/) is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. It provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams.

[FoundationDB](https://www.foundationdb.org/) is an open source distributed database designed to handle large volumes of structured data across clusters of commodity servers. It organizes data as an ordered key-value store and employs ACID transactions for all operations. It is especially well-suited for read/write workloads but also has excellent performance for write-intensive workloads. FoundationDB was acquired by [Apple in 2015](https://techcrunch.com/2015/03/24/apple-acquires-durable-database-company-foundationdb/).

[IBM DB2](https://www.ibm.com/analytics/db2) is a collection of hybrid data management products offering a complete suite of AI-empowered capabilities designed to help you manage both structured and unstructured data on premises as well as in private and public cloud environments. Db2 is built on an intelligent common SQL engine designed for scalability and flexibility.

[Atlas](https://github.com/Netflix/atlas) is an in-memory dimensional [time series database](https://en.wikipedia.org/wiki/Time_series_database).

[CouchbaseDB](https://www.couchbase.com/) is an open source distributed [multi-model NoSQL document-oriented database](https://en.wikipedia.org/wiki/Multi-model_database). It creates a key-value store with managed cache for sub-millisecond data operations, with purpose-built indexers for efficient queries and a powerful query engine for executing SQL queries.

[dbWatch](https://www.dbwatch.com/) is a complete database monitoring/management solution for SQL Server, Oracle, PostgreSQL, Sybase, MySQL and Azure. Designed for proactive management and automation of routine maintenance in large scale on-premise, hybrid/cloud database environments.

[Cosmos DB Profiler](https://hibernatingrhinos.com/products/cosmosdbprof) is a real-time visual debugger allowing a development team to gain valuable insight and perspective into their usage of Cosmos DB database. It identifies over a dozen suspicious behaviors from your application’s interaction with Cosmos DB.

[Adminer](https://www.adminer.org/) is an SQL management client tool for managing databases, tables, relations, indexes, users. Adminer has support for all the popular database management systems such as MySQL, MariaDB, PostgreSQL, SQLite, MS SQL, Oracle, Firebird, SimpleDB, Elasticsearch and MongoDB.

[DbVisualizer](https://dbvis.com/) is a SQL management tool that allows users to manage a wide range of databases such as Oracle, Sybase, SQL Server, MySQL, H3, and SQLite.

[AppDynamics Database](https://www.appdynamics.com/supported-technologies/database) is a management product for Microsoft SQL Server. With AppDynamics you can monitor and trend key performance metrics such as resource consumption, database objects, schema statistics and more, allowing you to proactively tune and fix issues in a High-Volume Production Environment.

[Toad](https://www.quest.com/toad/) is a SQL Server DBMS toolset developed by Quest. It increases productivity by using extensive automation, intuitive workflows, and built-in expertise. This SQL management tool resolve issues, manage change and promote the highest levels of code quality for both relational and non-relational databases.

[Lepide SQL Server](https://www.lepide.com/sql-storage-manager/) is an open source storage manager utility to analyse the performance of SQL Servers. It provides a complete overview of all configuration and permission changes being made to your SQL Server environment through an easy-to-use, graphical user interface.

[Sequel Pro](https://sequelpro.com/) is a fast MacOS database management tool for working with MySQL. This SQL management tool helpful for interacting with your database by easily to adding new databases, new tables, and new rows.

# KDE and the KDE Plasma Desktop

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

<p align="center">
  <img src="https://user-images.githubusercontent.com/45159366/161355802-089e9fb4-3164-4b4f-997d-c6d56a88c992.png">
  <br />
</p>

[KDE e.V.](http://ev.kde.org/) is the foundation which oversees the community for financial and legal representation.

[KDE Free Qt Foundation](https://kde.org/community/whatiskde/kdefreeqtfoundation/) is an organization with the purpose of securing the availability of the Qt toolkit for the development of Free Software and in particular for the development of KDE software. The Foundation has license agreements with The Qt Company, Digia, and Nokia.

[What is KDE?](https://kde.org/community/whatiskde/)

[KDE Wikis](https://wiki.kde.org/)

<p align="center">
  <img src="https://user-images.githubusercontent.com/45159366/161355805-ddd57559-9e0d-45d1-9537-08b6ad537e99.png">
  <br />
</p>

[KDE Plasma Desktop](https://kde.org), is a beautiful Windows-like desktop that you use to surf the web, keep in touch with colleagues, friends and family, manage your files, enjoy music and videos; and get creative and productive at work. The KDE community develops and maintains [more than 200 applications](https://apps.kde.org/) which run on any Linux desktop, and other platforms such as [KDE Applications for the Windows Desktop](https://apps.kde.org/platforms/windows/).

<h3 align="center">
  <img src="https://user-images.githubusercontent.com/45159366/93250998-758b7080-f748-11ea-814e-40e04ac3df4b.jpeg">
  <br />
  KDE Plasma Desktop
</h3>

## KDE Plasma Discover Software Center

[Discover - KDE Community Wiki](https://community.kde.org/Discover)

[Discover](https://apps.kde.org/discover/) is a software package mangaer that manages software from multiple sources, including your operating system's software repository, Flatpak repos, the Snap store, or even AppImages from store.kde.org. 

<p align="center">
<img src="https://user-images.githubusercontent.com/45159366/145691934-52154d53-2457-4226-be11-ee23d4520c74.png">
<br />
 KDE Discover Software Center
</p>

# Wayland Development

[Back to the Top](https://github.com/mikeroyal/Qt-Guide#table-of-contents)

<p align="center">
 <img src="https://user-images.githubusercontent.com/45159366/104235197-79cf4e00-5409-11eb-97a6-a12f7bd8ad2a.png">
  <br />
</p>

## Wayland Learning Resources

[Wayland](https://wayland.freedesktop.org) is a protocol for a compositor to talk to its clients as well as a C library implementation of that protocol. The compositor can be a standalone display server running on Linux kernel modesetting and evdev input devices, an [X application](https://www.x.org/wiki/XServer/), or a wayland client itself.

[QtWayland](https://wiki.qt.io/QtWayland) is a Qt 5 module that wraps the functionality of Wayland. QtWayland is separated into a client and server side. The client side is the wayland platform plugin, and provides a way to run Qt applications as Wayland clients.

[Qt Wayland Compositor](https://doc.qt.io/qt-5/qtwaylandcompositor-index.html)

[Qt Wayland Compositor Examples](https://doc.qt.io/qt-5/qtwaylandcompositor-examples.html)

[Wayland Architecture](https://wayland.freedesktop.org/architecture.html)

[Wayland Documentation](https://wayland.freedesktop.org/docs/html/)

[Sotfware Toolkits that have Wayland support right now](https://wayland.freedesktop.org/toolkits.html)

[Contribution instructions for Wayland](https://gitlab.freedesktop.org/wayland/wayland/blob/master/CONTRIBUTING.md)

[Contribution instructions for Weston](https://gitlab.freedesktop.org/wayland/weston/blob/master/CONTRIBUTING.md)

[Reporting Wayland bugs](https://gitlab.freedesktop.org/wayland/wayland/issues)

[Reporting Weston bugs](https://gitlab.freedesktop.org/wayland/weston/issues)

[WSLG: X11 and Wayland Applications in Windows Subsystem for Linux(WSL2)](https://linuxplumbersconf.org/event/9/contributions/611/attachments/702/1298/XDC2020_-_X11_and_Wayland_applications_in_WSL.pdf)

[Wayland on ArchWiki](https://wiki.archlinux.org/index.php/Wayland)

[Sway on ArchWiki](https://wiki.archlinux.org/index.php/Sway)

[Wayland on Ubuntu Wiki](https://wiki.ubuntu.com/Wayland)

[Wayland on Debian Wiki](https://wiki.debian.org/Wayland)

[The Wayland Display Server on Fedora Docs](https://docs.fedoraproject.org/en-US/fedora/rawhide/system-administrators-guide/Wayland/)

[Wayland features on Fedora Project Wiki](https://fedoraproject.org/wiki/Wayland_features)

[Wayland on GNOME Wiki](https://wiki.gnome.org/Initiatives/Wayland)

[KWin/Wayland on KDE Community Wiki](https://community.kde.org/index.php?title=KWin/Wayland)

[Wayland Desktop Landscape on Gentoo Wiki](https://wiki.gentoo.org/wiki/Wayland_Desktop_Landscape)

[Wayland in Void Linux Handbook](https://docs.voidlinux.org/config/graphical-session/wayland.html)

[Wayland on Enlightenment DE](https://www.enlightenment.org/about-wayland)

## Wayland Tools

[Weston](https://gitlab.freedesktop.org/wayland/weston) is a lightweight and functional Wayland compositor.

[XWayland](https://wayland.freedesktop.org/xserver.html) is an X Server running as a Wayland client(for backwards compatibility), allowing the [Xorg server](https://www.x.org/wiki/XServer/) can be modified to use wayland input devices for input and forward either the root window or individual top-level windows as wayland surfaces.

[KWayland](https://github.com/KDE/kwayland-server) is a Qt-style API to interact with the wayland-client and wayland-server API.

[NVIDIA Wayland EGL External Platform library](https://github.com/NVIDIA/egl-wayland) is a work-in-progress implementation of a EGL External Platform library to add client-side Wayland support to EGL on top of EGLDevice and EGLStream families of extensions.

[NVIDIA EGL External Platform Interface](https://github.com/NVIDIA/eglexternalplatform) is a work-in-progress specification of the EGL External Platform interface for writing EGL platforms and their interactions with modern window systems on top of existing low-level EGL platform implementations. This keeps window system implementation specifics out of EGL drivers by using application-facing EGL functions.

[GTK](https://www.gtk.org/) is a free and open source cross-platform widget toolkit for creating graphical user interfaces developed by [GNOME Project](https://www.gnome.org/). It is one of the most popular toolkits for the Wayland and X11 windowing.

[Sway](https://swaywm.org/) is an [i3](https://i3wm.org/)-compatible Wayland compositor.

[wlroots](https://github.com/swaywm/wlroots) is a modular Wayland compositor library.

[WayfireWM](https://github.com/WayfireWM/wayfire) is a 3D Wayland compositor, inspired by [Compiz](https://launchpad.net/compiz) and based on [wlroots](https://github.com/swaywm/wlroots).

[SDDM](https://github.com/sddm/sddm) is a modern display manager for X11 and Wayland aiming to be fast, simple and beautiful. It uses modern technologies like QtQuick, which in turn gives the designer the ability to create smooth, animated user interfaces.

[x11docker](https://github.com/mviereck/x11docker) is an application that you allows to run graphical desktop applications (and entire desktops) in Docker Linux containers.

[Mako](https://github.com/emersion/mako) is a lightweight notification daemon for Wayland. It also works on [Sway](https://swaywm.org/).

[Wayland-rs](https://github.com/Smithay/wayland-rs) is a Rust implementation of the wayland protocol (client and server).

## Contribute

- [x] If would you like to contribute to this guide simply make a [Pull Request](https://github.com/mikeroyal/Qt-Guide/pulls).


## License

Distributed under the [Creative Commons Attribution 4.0 International (CC BY 4.0) Public License](https://creativecommons.org/licenses/by/4.0/).
